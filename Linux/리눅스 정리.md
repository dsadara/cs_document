# 리눅스

## 1. 리눅스 기본 명령어들

### pwd

### cd

- cd ..
- cd ~
- cd -
    - 이전 경로로 이동
- cd /etc/efw
    - 절대경로 사용

### ls

- ls -al
    - 숨길파일까지 다 보기
    - 파일 권한
        - rwxrwxrwx
        - 소유자, 그룹, 공개 순서
        - 읽기(r), 쓰기(w), 실행(x)

### chmod

- 파일 권한 변경

    ![Untitled](https://user-images.githubusercontent.com/22488593/196186884-1b2d745f-c75e-46de-9394-92c48b9a6487.png)

- rwxrwxrwx = 777
- r———— = 400
- chmod -R 777 directory
    - 디렉토리에 해당하는 모든 파일을 rwxrwxrwx로 바꾸라는 것
- man
    - 메뉴얼 보기

### 리눅스 그룹

- 리눅스는 다중 사용자가 동시에 사용가능하게 만든 운영체제
    - 시분할 시스템을 사용해서
    - 여러 사용자의 그룹을 나눌 필요성이 생김

### cat

- 파일의 내용을 표시

### rm

- 파일 및 폴더 삭제
- rm -rf
    - r : 하위 디렉토리를 포함한 모든 파일 삭제
    - f : 강제로 파일이나 디렉토리 삭제

### 표준 입출력

- 프로세스는 세 가지 스트림을 가지고 있음
    - 표준 입력 스트림 : stdin
    - 표준 출력 스트림 : stdout
    - 오류 출력 스트림 : stderr

### 리다이렉션(redirection)

- 표준 스트림 흐름을 바꿔주는 것
    - \>, <을 사용
    - stdout을 파일에 넣고 싶을 때
        - ls -al > temp.txt
    - 파일을 stdin에 넣고 싶을 때
    - \>>, <<을 쓰면 기존 파일에 추가를 해줌

### 파이프(pipe)

- 한 프로세스의 출력 스트림을 다른 프로세스의 입력 스트림으로 사용
    - ls | grep kernel
        - ls 결과 중 kernel로 시작하는 것만을 출력

### grep

- 검색 명령

### 포그라운드 프로세스

- 해당 프로세스 수행 종료까지 다른 사용자의 입력을 받지 못하는 프로세스
- 프그라운드 프로세스 실행 중 다음 명령어를 칠 수 없다
- 실행이 너무 오래 걸리면 ctrl + c 로 작업을 취소 가능

### 백그라운드 프로세스

- 사용자 입력과 상관없이 실행되는 프로세스
- 백그라운드 프로세스 실행중에는 다음 명령어를 칠 수 있다
- 프로세스 실행 시 맨 뒤에 &을 붙여줌
- 실행이 완료하면 작업 번호와 pid를 출력함
    - [1] 57

### jobs

- 실행중인 백그라운드 프로세스 출력

### fg

- 백그라운드 프로세스를 포그라운드 프로세스로 변경
- fg %2
    - 2번 프로세스를 포그라운드로 변경

### ps

- 프로세스 상태 확인
- ps aux 로 많이 씀
    - a : 모든 사용자의 프로세스를 출력
    - u : 프로세스 소유자 정보도 출력
    - x : 데몬 프로세스나 기타 프로세스도 출력
        - 현재 shell에서 실행하지 않은 프로세스도 출력함

### Daemon 프로세스

- 백그라운드에서 계속 실행되고 있는 프로세스

### kill 명령어

- 프로세스를 종료시키기
    - 백그라운드 프로세스를 종료시키기 위해 씀
- 사용법
    - kill % job number
    - kill pid
- -9
    - 조건에 상관없이 강제 작업 종료
    - kill -9 41189

### cp 명령어

- 파일 복사
- cp -rf * 폴더

## 1.1. 심볼릭 링크

### 하드링크

- ln A B
    - A와 B는 동일한 파일을 가리킴
- A를 삭제해도 B로 해당 파일 접근 가능

### 소프트링크

- ln -s A B
- 윈도우 바로가기와 동일
- A를 삭제하면 B는 해당 파일 접근 불가

## 1.2. 편하게 쓸 수 있어야 할 명령어

- ps aux | grep 프로세스명
    - 프로세스가 실행 중인지 확인하고, 관련 프로세스에 대한 정보 출력
- kill -9 pid
    - 해당 프로세스를 강제로 죽임
- 명령 &
    - 백그라운드로 프로세스 실행
- Ctrl + c
    - 프로세스 종료

## 2. ubuntu 패키지 관리

### 패키지란?

리눅스 시스템에서 **소프트웨어를 실행하는데 필요한 파일들**이 담겨 있는 설치 파일 묶음이다.

- 실행 파일, 설정 파일, 라이브러리 등

### Source 패키지

컴파일 과정을 통해 바이너리 파일로 만들어야 실행 가능

### Binary 패키지

컴파일 되어 있어 바로 실행할 수 있음

- **패키지 의존성**
    - 패키지가 컴파일된 환경과 내 컴퓨터가 달라서 문제가 생길 수 있음
    - 특정 버전의 라이브러리를 갖고 있지 않으면 실행 시킬 수 없을 수 있음

### 저수준 패키지 도구

패키지 파일을 설치하거나 제거할 때 사용하는 도구

- dpkg

### 고수준 패키지 도구

패키지 파일을 설치하거나 제거할 수 있고 **패키지 의존성**도 해결해주는 도구

- apt-get, apt, aptitute

### sudo apt-get update

패키지 인덱스 정보 업데이트

### sudo apt-get upgrade

패키지 인덱스 정보를 업데이트하고 프로그램을 최신 버전으로 업데이트도 함

- 다른 프로그램과 함께 동작하는 부분이 테스트된 적 없어서 정상적으로 동작하지 않을 수도 있음

### sudo apt-get install 패키지명

패키지 설치

### sudo apt-get remove 패키지명

설정파일 제외 삭제

- 설정파일 포함 삭제: sudo apt-get —purge remove 패키지명
- 삭제해도 정상 삭제가 안되는 경우가 많음
    - 설정 파일, 남겨진 파일들을 일일이 삭제해줘야 하는 경우가 많음

## 3. VIM 에디터 기본 사용법

### 일반 모드

찾기, 커서 이동, 삭제 가능 

- 처음 vim 실행 시 또는 입력 모드/명령 모드에서 ESC입력 시 실행 됨

| i | 커서 위치에서 편집모드 시작 |
| --- | --- |
| a | 커서 위치 바로 다음에서 편집모드 시작 |
| x | 커서의 한 문자를 삭제 |
| dd | 커서의 현재 라인을 삭제 |
| shift + j | 커서의 아랫라인과 현재 라인을 하나의 라인으로 합침 |
| /찾을단어 | 단어 위치로 이동 n을 누르면 다음 단어로 이동 |

### 명령 모드

저장, 파일읽기, vim설정 가능

- 일반 모드에서 : 입력 시 실행 됨

| :w | 현재 오픈된 파일 저장 |
| --- | --- |
| :q | 저장하지 않고 종료 (quit) |
| :wq | 현재 오픈된 파일 저장 후 종료 |
| :q! | 강제 종료 (대소문자 구분) |
| :0 | 맨 첫줄로 이동 |
| :$ | 맨 끝줄로 이동 |
| :set |  vim 설정 변경 가능 |

### 입력 모드

내용 입력

- 일반 모드에서 a 또는 i 또는 o키 입력 시

### Visual 모드

블록 복사/붙이기

- 일반 모드에서 v 입력 시 실행 됨

| v | 단어 단위로 블럭 지정 |
| --- | --- |
| shift + v | 라인 단위로 블럭 지정 |
| y | 지정된 블럭을 복사 |
| p | 복사된 블럭을 현재 커서에 붙임 |
| u | 직전 실행 작업 취소 |

### vim 설정법

- 명령 모드에서 set all 입력하면 vim에서 설정할 수 있는 모든 옵션이 나옴
    - 주요 옵션
        
        ![Untitled 1](https://user-images.githubusercontent.com/22488593/196187088-b0871d7c-6b4c-486b-a064-c770189db189.png)

        
- ~/.vimrc 파일에서 설정 하면 기본으로 설정 가능
    - 홈 폴더 안에 .vimrc 파일을 만들어 주어야 함

## 4. 쉘 스크립트

쉘 명령어를 기본으로 하는 스크립트

- 첫 라인은 #!/bin/bash 로 시작
- 쉘 스크립트 파일은 실행 권한을 가지고 있어야 함
    - chmod 764 filename.sh
- 파일 이름.sh와 같은 형태로 파일 이름 저장
- 주석은 #

### 변수

- 선언
    
    변수명=데이터
    
- 사용
    
    $변수명
    

```bash
#!/bin/bash

mysql_id='root'
mysql_directory="/etc/mysql"

echo $mysql_id
echo $mysql_directory
```

### 배열

- 선언
    
    변수명=( 데이터1 데이터2 데이터3 … ) 
    
- 사용
    
    $(변수명[인덱스번호])
    

```bash
#!/bin/bash

daemons=("httpd" "mysqld" "vsftpd")
echo $(daemons[1]) # 배열의 두번째 원소 출력
echo ${daemons[*]} # 배열의 모든 데이터 춫
echo ${daemons[@]}

filelist=( $(ls) )
echo $(filelist[*])
```

### 사전에 정의된 변수

| $$ | 쉘 프로세스 번호 |
| --- | --- |
| $0 | 쉘스크립트 이름 |
| $1 ~ $9 | 명령줄 인수 |
| $* | 모든 명령줄 인수리스트 |
| $# | 인수의 개수 |
| $? | 최근 실행한 명령어 종료 값 |
- 종료 값
    - 0 (성공)
    - 1 ~ 125 (에러)
    - 126 (파일이 실행가능하지 않음)
    - 128 ~ 255 (시그널 발생)

### 연산자

- expr과  따옴표( ` )를 사용
    - 연산자 *와 괄호앞에는 역슬래시( \ )을 사용
    - 연산자, 숫자, 변수, 기호 사이에는 space를 넣어야 함\
        
        ```bash
        #!/bin/bash
        
        num=`expr \( 3 \* 5 \) / 4 + 7`
        echo $num
        ```
        
- bc를 사용하는 방법
    
    ```bash
    #!/bin/bash
    
    echo '(3*5)/4' | bc -l # -l : 부동소수점 출력
    ```
    

### 조건문

- 기본 if 구문과 else 구문
    
    ```bash
    if [ 조건 ]
    then
    	명령문
    fi
    ```
    
    - 조건문을 한 줄에 입력하려면 세미콜론( ; ) 사용
- 조건
    - 문자비교
        
        
        | 문자1 == 문자2 | 문자1과 문자2가 일치 |
        | --- | --- |
        | 문자1 != 문자2 | 문자1과 문자2가 일치하지 않음 |
        | -z 문자 | 문자가 null 이면 참 |
        | -n 문자 | 문자가 null 이 아니면 참
         |
    - 수치 비교
        
        
        | 값1 -eq 값2 | equal |
        | --- | --- |
        | 값1 -ne 값2 | not equal |
        | 값1 -lt 값2 | less than |
        | 값1 -le 값2 | less or equal |
        | 값1 -gt 값2 | greater than |
        | 값1 -ge 값2 | less or equal |
    - 파일 검사
        
        
        | -e filename | 파일이 존재하면 참 |
        | --- | --- |
        | -d filename | 파일이 디렉토리면 참 |
        | -h filename | 심볼릭 링크파일  |
        | -f filename | 파일이 일반 파일이면 참 |
        | -r filename | 파일이 읽기 가능이면 참 |
        | -s filename | 파일 크기가 0이 아니면 참 |
        | -u filename | 파일이 set-user-id가 설정되면 참 |
        | -w filename  | 파일이 쓰기 가능이면 참 |
        | -x filename | 파일이 실행 가능 상태이면 참 |
    - 논리 연산
        
        
        | 조건1 -a 조건2 | AND |
        | --- | --- |
        | 조건1 -o 조건2 | OR |
        | 조건1 && 조건2 | 양쪽 다 성립 |
        | 조건1 || 조건2 | 한쪽 또는 양쪽 다 성립 |
        | !조건 | 조건이 성립하지 않음 |
        | true | 조건이 언제나 성립 |
        | false | 조건이 언제나 성립하지 않음 |

### 반복문

- for 구문
    
    ```bash
    for 변수 in 변수값1 변수값2 ... 
    do
    	명령문
    done
    ```
    
    ```bash
    #!/bin/bash
    #사용 예 
    for database in $ (ls)
    do
    	echo $database
    done
    ```
    
- while 구문
    
    ```bash
    while [ 조건문 ]
    do
    	명령문
    done
    ```
    
    ```bash
    #!/bin/bash
    # 현재 디렉토리에 있는 파일과 디렉토리를 출력
    lists=$(ls)
    num=${#lists[@]}
    index=0
    while [ $num -ge 0 ]
    do 
    	echo ${lists[$index]}
    	index=`expr $index + 1`
    	num=`expr $num - 1`
    done
    
    ```
    

### 쉘 스크립트 사용 예제1: 백업하기

```bash
#!/bin/bash

if [ -z $1 ] || [ -z $2 ]; then
	echo usage: $0 sourcedir targetdir # 인자가 없으면 사용법 출력
else
	SRCDIR=$1
	DSTDIR=$2
	BACKUPFILE=backup.$(date +%y%m%d%H%M%S).tar.gz
	if [ -d $DSTDIR ]; then # 두번째 인자가 유효한 디렉토리이면
		tar -cvzf $DSTDIR/$BACKUPFILE $SRCDIR # 그곳에 압축
	else
		mkdir $DSTDIR # 유효한 디렉토리가 아니면 
		tar -cvzf $DSTDIR/$BACKUPFILE $SRCDIR # 그곳에 새 디렉토리를 만들고 압축
	fi
fi
```

- tar
    - 압축이 아닌 여러 파일을 한 파일로 묶은 것
    - 압축을 하려면 옵션을 줘서 gzip을 사용하면 됨
    - 주요 옵션
        
        
        | x | 묶음을 해제 |
        | --- | --- |
        | c | 파일을 묶음 |
        | v | 묶음/해제 과정을 화면에 표시 |
        | z | gunzip을 사용 |
        | f | 파일 이름을 지정 |
    - 압축 시 주로 사용하는 옵션
        
        tar -cvzf [압축된 파일 이름] [압축할 파일이나 폴더명]
        
    - 압축을 풀을 때 주로 사용하는 옵션
        
        tar -xvzf [압축 해제할 압축 아카이브 이름]
        

### 쉘 스크립트 사용 예제2: 로그 파일 정리하기

```bash
#!/bin/bash

LOGDIR=/var/log
GZIPDAY=1
DELDAY=2
cd $LOGDIR
echo "cd $LOGDIR"

# 만든지 1일 이내의 .log 파일을 찾으면 .gz 파일로 압축 
sudo find . -type f -name '*log.?' -mtime +$GZIPDAY -exec bash -c "gzip {}" \; 2> /dev/null
# 만든지 2일 이상 지난 .gz 파일이 있으면 삭제 
sudo find . -type f -name '*.gz' -mtime +$DELDAY -exec bash -c "rm -f {}" \; 2> /dev/null
```